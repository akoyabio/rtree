{
    "collab_server" : "",
    "contents" : "// [[Rcpp::depends(BH)]]\n\n// Enable C++11 via this plugin to suppress 'long long' errors\n// [[Rcpp::plugins(\"cpp11\")]]\n\n// Some of this code based on http://gallery.rcpp.org/articles/Rtree-examples/\n\n#include <vector>\n#include <Rcpp.h>\n#include <boost/geometry.hpp>\n#include <boost/geometry/geometries/point.hpp>\n#include <boost/geometry/geometries/box.hpp>\n#include <boost/geometry/index/rtree.hpp>\nusing namespace Rcpp;\n\n// Mnemonics\nnamespace bg = boost::geometry;\nnamespace bgi = boost::geometry::index;\ntypedef bg::model::point<float, 2, bg::cs::cartesian> point_t;\ntypedef bg::model::box<point_t> box;\ntypedef std::pair<point_t, unsigned int> value_t;\n\nclass RTreeCpp {\npublic:\n\n  // Constructor, creates R-Tree on points in mat\n  // mat must have 2 columns with x and y coordinates of points\n  RTreeCpp(NumericMatrix mat) {\n\n    coords = clone(mat);\n    int size = mat.nrow();\n    NumericVector x = mat(_,0);\n    NumericVector y = mat(_,1);\n    std::vector<value_t> point_value_pairs;\n\n    // Create vector of point-index pairs\n    for(int i = 0; i < size; ++i) {\n      point_t point_t(x[i], y[i]);\n      point_value_pairs.push_back(std::make_pair(point_t, static_cast<unsigned int>(i)));\n    }\n\n    // Create rtree using packing algorithm\n    bgi::rtree<value_t, bgi::quadratic<16> > rtree_new(point_value_pairs);\n    rtree_ = rtree_new;\n  }\n\n  // Within-box lookup\n  // box_vec is [lrx, lry, urx, ury] coordinates\n  std::vector<int> intersects(NumericVector box_vec) {\n    box query_box(point_t(box_vec[0], box_vec[1]), point_t(box_vec[2], box_vec[3]));\n    std::vector<value_t> result_n;\n    rtree_.query(bgi::intersects(query_box), std::back_inserter(result_n));\n    std::vector<int> indexes;\n    std::vector<value_t>::iterator itr;\n    for (itr = result_n.begin(); itr != result_n.end(); ++itr) {\n      value_t value = *itr;\n      indexes.push_back(value.second);\n    }\n    return indexes;\n  }\n\n  // Get euclidean distances between point and points referenced by their indexes\n  std::vector<double> get_distances(NumericVector point_vec, std::vector<int> indexes) {\n    point_t start = point_t(point_vec[0], point_vec[1]);\n    std::vector<double> distances;\n    for (int i = 0; i < indexes.size(); i++) {\n      point_t end = point_t(coords(indexes[i],0), coords(indexes[i],1));\n      double dist = bg::distance(start, end);\n      distances.push_back(dist);\n    }\n    return(distances);\n  }\n\n  // Get indices of points within distance of point\n  // Note: Returns R indices (starting at 1, not 0!)\n  std::vector<int> within_distance(NumericVector point_vec, double distance) {\n    std::vector<int> indist_indexes;\n    NumericVector box_vec = NumericVector::create(point_vec[0]-distance, point_vec[1]-distance,\n                                                  point_vec[0]+distance, point_vec[1]+distance);\n\n    std::vector<int> inbox_indexes = intersects(box_vec);\n    if (inbox_indexes.size()==0) {\n      return(indist_indexes);\n    }\n\n    std::vector<double> inbox_distances = get_distances(point_vec, inbox_indexes);\n    for (int i=0; i<inbox_distances.size(); i++) {\n      if (inbox_distances[i] <= distance) {\n        indist_indexes.push_back(inbox_indexes[i] + 1);\n      }\n    }\n    return(indist_indexes);\n  }\n\n  // Multi point version of within_distance\n  // Note: Returns R indices (starting at 1, not 0!)\n  List within_distance_list(NumericMatrix point_mat, double distance) {\n    List indist_indexes_ls(point_mat.nrow());\n    for (int i=0; i < point_mat.nrow(); i++){\n      NumericVector point_vec = point_mat(i,_);\n      std::vector<int> indist_indexes = within_distance(point_vec, distance);\n      indist_indexes_ls(i) = wrap(indist_indexes);\n    }\n    return(indist_indexes_ls);\n  }\n\n  // KNN\n  // Note: Returns R indices (starting at 1, not 0!)\n  std::vector<int> knn(NumericVector point, unsigned int n) {\n    std::vector<value_t> result_n;\n    rtree_.query(bgi::nearest(point_t(point[0], point[1]), n), std::back_inserter(result_n));\n    std::vector<int> indexes;\n    std::vector<value_t>::iterator itr;\n    for ( itr = result_n.begin(); itr != result_n.end(); ++itr ) {\n      value_t value = *itr;\n      indexes.push_back(value.second + 1);\n    }\n    return indexes;\n  }\n\n  // Multi point version of KNN\n  // Note: Returns R indices (starting at 1, not 0!)\n  List knn_list(NumericMatrix point_mat, unsigned int n) {\n    List knn_indexes_ls(point_mat.nrow());\n    for (int i=0; i < point_mat.nrow(); i++){\n      NumericVector point_vec = point_mat(i,_);\n      std::vector<int> knn_indexes = knn(point_vec, n);\n      knn_indexes_ls(i) = wrap(knn_indexes);\n    }\n    return(knn_indexes_ls);\n  }\n\nprivate:\n  bgi::rtree<value_t, bgi::quadratic<16> > rtree_;\n  NumericMatrix coords;\n};\n\nRCPP_MODULE(rtreecpp) {\n  class_<RTreeCpp>( \"RTreeCpp\" )\n\n  .constructor<NumericMatrix>()\n\n  .method( \"intersects\", &RTreeCpp::intersects)\n  .method( \"within_distance\", &RTreeCpp::within_distance)\n  .method( \"within_distance_list\", &RTreeCpp::within_distance_list)\n  .method( \"knn\", &RTreeCpp::knn)\n  .method( \"knn_list\", &RTreeCpp::knn_list)\n  ;\n}\n",
    "created" : 1488831825625.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3596357643",
    "id" : "D340F84B",
    "lastKnownWriteTime" : 1488852461,
    "last_content_update" : 1488852461455,
    "path" : "~/Projects/rtree/rtree/src/rtree.cpp",
    "project_path" : "src/rtree.cpp",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}