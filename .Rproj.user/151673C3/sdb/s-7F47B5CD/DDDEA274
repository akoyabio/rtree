{
    "collab_server" : "",
    "contents" : "---\ntitle: \"rtree package\"\nauthor: \"Philipp Hunziker\"\ndate: \"March 6, 2017\"\noutput: github_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\nThe rtree package offers fast Euclidean within-distance checks and KNN calculations for points in 2D space.\nIt offers significant speed-ups vis-a-vis simple implementations by relying on the [R-tree data structure](https://en.wikipedia.org/wiki/R-tree) implementation of <http://www.boost.org/>.\n\nrtree was inspired by [this](http://gallery.rcpp.org/articles/Rtree-examples/) example in the Rcpp gallery.\n\n<span style=\"color:red\">CAUTION</span>: This package is in development - its interface may change.\n\n## Installation\n\nYou can install the package directly from this repository:\n\n```{r eval=FALSE}\nlibrary(devtools)\ninstall_github(\"hunzikp/rtree\")\n```\n\n\n## Usage\n\nSay we have two large sets of points, A and B, stored as 2-column matrices of Euclidean coordinates:\n```{r simulate}\n## Simulate point coordinates\nset.seed(0)\nA_n <- 10^4\nA <- cbind(runif(A_n), runif(A_n))\nB_n <- 10^4\nB <- cbind(runif(B_n), runif(B_n))\ncolnames(A) <- colnames(B) <- c('x', 'y')\n```\n\n### Within-Distance Calculation\n\nFor each point of set $A$, $a_i$, we want to know all points of set $B$ that are within distance $d$ of $a_i$.\nTo compute this, we first create an R-Tree index on $B$:\n```{r index}\nlibrary(rtree)\n\n## Set index\nB_rtree <- RTree(B)\n```\n\nThe RTree function creates an S3 object of class RTree,\n```{r class}\ninherits(B_rtree, 'RTree')\n```\nwhich essentially just points to a C++ object of class RTreeCpp.\n\nUsing the RTree object, we can now perform our query efficiently:\n```{r within}\n## Within distance calculation\nd <- 0.05\nwd_ls <- withinDistance(B_rtree, A, d)\n```\nwd_ls is a list of length nrow(A)...\n```{r check}\nnrow(A)==length(wd_ls)\n```\n...whereby the $i$th list element contains the row-indices of the points in $B$ that are within distance $d$ of point $a_i$:\n```{r check2}\nprint(wd_ls[[1]])\n```\n\nWe can also check the sanity of the result visually:\n```{r checkplot, fig.cap = \"Within distance sanity check.\", message=FALSE, warning=FALSE}\nlibrary(plotrix)\n\n## Plot points in B within distance d of point a_1\na_1 <- A[1,]  # Get coords of a_1\nplot(a_1[1], a_1[2], xlim=c(a_1[1]-d, a_1[1]+d), ylim=c(a_1[2]-d, a_1[2]+d), \n     col='black', asp=1, pch=20, xlab='x', ylab='y')  # Plot a_1\npoints(B[,1], B[,2], col='grey')  # Plot B in grey\ndraw.circle(a_1[1], a_1[2], d)  # Draw circle of radius d\nb_wd <- B[wd_ls[[1]],]  # Get relevant points in B\npoints(b_wd[,1], b_wd[,2], col='red', pch=20)  # Plot relevant points in red\n```\n\n### Nearest Neighbor Calculation\n\nFor each point of set $A$, $a_i$, we want to know the $k$ points in B closest to $a_i$.\nRecycling the RTree object created above, we perform the knn computation...\n```{r knn}\n## KNN calculation\nk <- 10L\nknn_ls <- knn(B_rtree, A, k)\n```\n...which returns a list of the same format as above, with the exception that each element of knn_ls is exactly of length $k$.\n\nAgain, we may plot the result to inspect its veracity:\n```{r checkplot2, fig.cap = \"KNN sanity check.\", message=FALSE, warning=FALSE}\nlibrary(plotrix)\n\n## Plot points in B within distance d of point a_1\na_1 <- A[1,]  # Get coords of a_1\nplot(a_1[1], a_1[2], xlim=c(a_1[1]-d, a_1[1]+d), ylim=c(a_1[2]-d, a_1[2]+d), \n     col='black', asp=1, pch=20, xlab='x', ylab='y')  # Plot a_1\npoints(B[,1], B[,2], col='grey')  # Plot B in grey\nb_knn <- B[knn_ls[[1]],]  # Get relevant points in B\npoints(b_knn[,1], b_knn[,2], col='red', pch=20) # Plot relevant points in red\n```\n\n## Benchmarking\n\nAll benchmarks are performed on a i7-6920HQ CPU @ 2.90GHz.\n\n### Within-Distance Benchmarks\n\nWe first compare the within-distance functionality to the gWithinDistance function offered in [rgeos](https://cran.r-project.org/package=rgeos) (version 0.3-21).\n```{r wd_bench, fig.cap = \"\", message=FALSE, warning=FALSE}\n## Load packages\nlibrary(sp)\nlibrary(rgeos)\nlibrary(rbenchmark)\n\n## Simulate data\nset.seed(0)\nA_n <- 10^3\nA <- cbind(runif(A_n), runif(A_n))\nB_n <- 10^3\nB <- cbind(runif(B_n), runif(B_n))\nd <- 0.05\n\n## Encapsulate wd operations in functions, then benchmark\nrgeos.wd <- function() {\n  wd_mat <- gWithinDistance(spgeom1=SpatialPoints(A), spgeom2=SpatialPoints(B), dist=d, byid=TRUE)\n}\nrtree.wd <- function() {\n  wd_ls <- withinDistance(RTree(B), A, d)\n}\nbm.wd <- benchmark(rtree=rtree.wd(),\n                   rgeos=rgeos.wd(),\n                   replications=10,\n                   columns=c(\"test\", \"replications\", \"elapsed\", \"relative\"))\n\n## Print output\nprint(bm.wd)\n\n## Plot\nbarplot(bm.wd$relative, names.arg=bm.wd$test,\n        ylab=\"Relative Time Elapsed\", cex.main=1.5)\nmtext(\"within distance\", line=3, cex=1.5, font=2)\nspeedup <- round(bm.wd$relative[bm.wd$test==\"rgeos\"], 1)\nmtext(paste(\"rtree \", speedup, \"x faster than rgeos\", sep=\"\"), \n      line=1.5, cex=1.25)\n```\n\n### KNN Benchmarks\n\nNext we compare the KNN functionality with the KNN implementation based on kd-trees offered in the [FNN](https://cran.r-project.org/package=FNN) package (version 1.1).\nWe don't offer benchmarking statistics against a linear search KNN implementation, which would obviously be much, much slower.\n```{r knn_bench, fig.cap = \"\", message=FALSE, warning=FALSE}\n## Load packages\nlibrary(FNN)\n\n## Simulate data\nset.seed(0)\nA_n <- 10^4\nA <- cbind(runif(A_n), runif(A_n))\nB_n <- 10^4\nB <- cbind(runif(B_n), runif(B_n))\nk <- 100L\n\n## Encapsulate knn operations in functions, then benchmark\nkdtree.knn <- function() {\n  nn.idx <- get.knnx(data=B, query=A, k=k, algorithm=c(\"kd_tree\"))\n}\nrtree.knn <- function() {\n  nn_ls <- rtree::knn(RTree(B), A, k)\n}\nbm.knn <- benchmark(rtree=rtree.knn(),\n                    kdtree=kdtree.knn(),\n                    replications=10,\n                    columns=c(\"test\", \"replications\", \"elapsed\", \"relative\"))\n\n## Print output\nprint(bm.knn)\n\n## Plot\nbarplot(bm.knn$relative, names.arg=bm.knn$test,\n        ylab=\"Relative Time Elapsed\", cex.main=1.5)\nmtext(\"KNN\", line=3, cex=1.5, font=2)\nspeedup <- round(bm.knn$relative[bm.knn$test==\"kdtree\"], 1)\nmtext(paste(\"rtree \", speedup, \"x faster than FNN (kd-tree)\", sep=\"\"), \n      line=1.5, cex=1.25)\n```\n\n\n\n\n",
    "created" : 1488832771561.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1836281364",
    "id" : "DDDEA274",
    "lastKnownWriteTime" : 1488855941,
    "last_content_update" : 1488855941039,
    "path" : "~/Projects/rtree/rtree/README.Rmd",
    "project_path" : "README.Rmd",
    "properties" : {
        "last_setup_crc32" : "682049C7bb338d19",
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}